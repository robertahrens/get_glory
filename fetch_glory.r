# Packages not available via CRAN
remotes::install_github("skgrange/threadr")
remotes::install_github("markpayneatwork/RCMEMS")

# ensure executable permission, once for all
chmod u+x copernicusmarine_macos-arm64.cli
# run the data query
./copernicusmarine_macos-arm64.cli get -i cmems_mod_glo_phy_my_0.083deg_P1D-m --filter "*_20150401*" --dry-run


# The packages we will use
library(tidyverse) # A staple for most modern data management in R
library(RCurl) # For helping R to make sense of URLs for web hosted data
library(XML) # For reading the HTML tables created by RCurl
library(tidync) # For easily dealing with NetCDF data
library(doParallel) # For parallel processing
library(threadr) # For downloading from FTP sites that require user credentials
library(RCMEMS) # For subsetting CMEMS data before download
library(dplyr)
#load in observer data 
load("/Users/robert.ahrens/Documents/data/pirop/data/obs_sets_1994_2023.Rdata")
#filter down to deepset and generate id code to match ocean data code
obs_dsll <- obs_sets[which(obs_sets$DECLARED_TRIP_TYPE_CODE == "D" & substr(obs_sets$TRIP_NUM,1,2) == "LL"),]
#get mean time for 
tmp <- cbind(obs_dsll$SET_BEGIN_DATETIME, obs_dsll$SET_END_DATETIME, obs_dsll$HAUL_BEGIN_DATETIME, obs_dsll$HAUL_END_DATETIME)
tz_cor <- 60 * 60 * 10
mean_seconds <- apply(tmp, 1, mean, na.rm = TRUE)
obs_dsll$MEAN_SET_TIME <- strptime("1970-01-01 00:00:00", "%Y-%m-%d %H:%M:%S") + mean_seconds - tz_cor
#get centroid lat and lon
obs_dsll$CLAT <- apply(cbind(obs_dsll$SET_BEGIN_LAT,  obs_dsll$SET_END_LAT,  obs_dsll$HAUL_BEGIN_LAT, obs_dsll$HAUL_END_LAT), 1, mean, na.rm = TRUE)
obs_dsll$CLON <- apply(cbind(obs_dsll$SET_BEGIN_LON, obs_dsll$SET_END_LON, obs_dsll$HAUL_BEGIN_LON, obs_dsll$HAUL_END_LON), 1, mean, na.rm = TRUE)
#get rid of NA 
ii <- is.na(obs_dsll$CLAT) | is.na(obs_dsll$CLON) | is.na(obs_dsll$MEAN_SET_TIME)
df <- subset(obs_dsll[ , c("SET_ID", "MEAN_SET_TIME", "CLON", "CLAT")], subset = !ii)
save(df, file = "/Users/robert.ahrens/Documents/GitHub/get_glory/tmp_df.rdata")
rm(list = c("obs_dsll", "obs_sets"))
gc()
load("/Users/robert.ahrens/Documents/GitHub/get_glory/tmp_df.rdata")


g_res <- 1 / 12
x_min <- min(df$CLON)
x_min <- x_min - x_min %% g_res
x_max <- max(df$CLON)
x_max <- x_max + g_res - x_max %% g_res
y_min <- min(df$CLAT)
y_min <- y_min - y_min %% g_res
y_max <- max(df$CLAT)
y_max <- y_max + g_res - y_max %% g_res
d_min <- 200
d_max <- 200

# Non-R software
# Unfortunately the subsetting of CMEMS data will require that one has Python installed
# https://www.python.org/downloads/
# Then one must download
# https://github.com/clstoulouse/motu-client-python/releases
# For instructions on how and why to properly install please see:
# https://github.com/markpayneatwork/RCMEMS

# Here is a cunning method of generating a brick of year-month values
date_range <- base::expand.grid(2023:2023, 1:12) %>% 
  dplyr::rename(year = Var1, month = Var2) %>% 
  arrange(year, month) %>% 
  mutate(year_mon = paste0(year,"-",month)) %>% 
  dplyr::select(year_mon)

# Download function
  # NB: This function is currently designed to subset data to a specific domain
  # Please change your lon/lat accordingly
  # NB: This function will save files to data/GLORYS in the root directory
  # To change this change the --out-dir argument near the end of the chunk of text
  # NB: This big text chunk needs to be left as one long line
  # NB: The --user and --pwd arguments need to be given the users real username and passwords
  # from their CMEMS account
  # The GLORYS script
    # This is a dummy script first generated by using the UI on the CMEMS website
    # No need to change anything here except for the --user and --pwd at the end
    # Please place your CMEMS username and password in those fields
mcloc <- "/Users/robert.ahrens/motuclient/motuclient-python/motuclient.py"
motu <- "--motu http://my.cmems-du.eu/motu-web/Motu"
service <- "--service-id GLOBAL_ANALYSISFORECAST_BGC_001_028"
product <- "--product-id cmems_mod_glo_bgc-bio_anfc_0.25deg_P1M-m"
lon_min <- paste("--longitude-min", x_min)
lon_max <- paste("--longitude-max", x_max)
lat_min <- paste("--latitude-min", y_min)
lat_max <- paste("--latitude-max", y_max)
depth_min <- paste(" --depth-min", d_min)
depth_max <- paste(" --depth-max", d_max)
variables <-"--variable o2 "
data_out <- paste("--out-dir", "/Users/robert.ahrens/Documents/GitHub/get_glory/data/")
file_name <- paste("--out-name", "ox_200.nc")
user_name <- paste("--user", "robert.ahrens@noaa.gov")
pass <- paste("--pwd", "#Cm3msF0rM3#")
start_date <- "2022-01-01"
end_date <- "2024-12-31"

GLORYS_script <- paste("python3", mcloc, motu, service, product, lon_min, lon_max, lat_min, lat_max, depth_min, depth_max, variables, data_out, file_name, user_name, pass)
#GLORYS_script <- 'python ~/motuclient/motuclient-python/motu-client.py --motu http://my.cmems-du.eu/motu-web/Motu --service-id GLOBAL_REANALYSIS_PHY_001_030-TDS --product-id global-reanalysis-phy-001-030-daily --longitude-min -180 --longitude-max 179.9166717529297 --latitude-min -80 --latitude-max 90 --date-min "2018-12-25 12:00:00" --date-max "2018-12-25 12:00:00" --depth-min 0.493 --depth-max 0.4942 --variable thetao --variable bottomT --variable so --variable zos --variable uo --variable vo --variable mlotst --variable siconc --variable sithick --variable usi --variable vsi --out-dir data --out-name test.nc --user username --pwd password'

  # Prep the necessary URL pieces
  date_start <- parse_date(date_choice, format = "%Y-%m")
  # A clever way of finding the end date of any month!
    # I found this on stackoverflow somewhere...
  date_end <- date_start %m+% months(1) - 1
  
  # Cannot get data past 2018-12-25
  if(date_end > as.Date("2018-12-25")) date_end <- as.Date("2018-12-25")
  
  # Set the file name
  file_name <- paste0("GLORYS_",date_choice,".nc")
  
  # Take the chunk of code above and turn it into something useful
  cfg <- parse.CMEMS.script(GLORYS_script, parse.user = T)
  
  # This is where one should make any required changes to the subsetting of the data
  # This is now the magic of the RCMEMS package, which allows us to interface with the Python code as though it were R
  cfg_update <- RCMEMS::update(cfg, 
                               date.min = as.character(start_date),
                               date.max = as.character(end_date))
  
  # Download and save the file if needed
  if(file.exists(paste0(data_out,file_name))){
    return()
  } else{
   CMEMS.download(cfg_update)
  }
  Sys.sleep(2) # Give the server a quick breather
}

# I've limited the download to only 1 file
# Delete '[1]' to download everything
  #NB: The CMEMS server is a little wonky, rather not try to multicore this
plyr::l_ply(date_range$year_mon[1], .fun = download_GLORYS, .parallel = F)
